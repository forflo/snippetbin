
import java.io.*;

/**
 + This class supplies some routines, that are useful
 + and needet in many other classes ...
 + @author Florian Mayer
 + @version 0.1
*/
public class GeneralUtil{
	public static SqliteBridge bridge = new SqliteBridge();
	public static final int RANGE_MIN = 65;
	public static final int RANGE_MAX = 90;
	public static final int CARD_VALUE_MAX = 500;
	public static final int CARD_VALUE_MIN = 1;
	public static final int STD_ID_LENGTH = 200;
	public static final int PIN_LENGTH = 4;

	//stores the path of the legacy database...
	private static String dbName = "testdb";

	//some cities
	public static final String[] CITIES = { "Hamburg", "Bamberg", "München", "Rosenheim", "Würzburg", "Mannheim", "Berlin", "Hannover", "Bremen"};	

	/**
	 + Generates a string, emulating the information on a ATM Card.
	 + This String is generated by using the Math.random() method and
	 + applies to the following regular expression: [A-Z]*
	 + @return <p> 	A String, representing the information that is
	 + 		normally stored on a ATM Card 	</p>
	 + @param <p> 	The number of chars containt in the
	 +		final result. The length mus be between
			one and 500			</p>
	 + @throws <p>	IllegalArgumentException 	</p>
	 + 
	*/
	public static String getCardValue(int length) throws IllegalArgumentException {
		if ( length > CARD_VALUE_MAX || length < CARD_VALUE_MIN )
			throw new IllegalArgumentException("Es sind nur Werte zwischen " + CARD_VALUE_MAX + " und " + CARD_VALUE_MIN + " erlaubt ! ");
		char[] result = new char[length];
		for (int i = 0; i < length; i++)
			result[i] = (char) (RANGE_MIN + Math.round(Math.random() * (RANGE_MAX - RANGE_MIN)));
		return new String(result);
	}
	
	/**
	 + Returns a random german city as location for the cashpoint
	 + @return <p> A string, representing a german city </p>
	 + @param none
	*/
	public static String getRandomCity() {
		return CITIES[(int)(Math.round(Math.random() * (CITIES.length - 1)))];
	}

	/**
	 + Returns an alphanumeric id, which is unique, or at least
	 + should be :)
	 + @return <p> Alphanumeric id </p>
	 + @param <p> The lenght of the id-string </p> 
	*/
	public static String getID(int length) {
		char[] result = new char[length];
		for(int i = 0; i < length; i++){
			int tmp = (int) Math.round((Math.random() *  2));
			if (tmp == 2) {
				result[i] = (char) (48 + Math.round(Math.random() * (57 - 48)));
			} else if (tmp == 1)  {
				result[i] = (char) (97 + Math.round(Math.random() * (122 - 97)));
			} else {
				result[i] = (char) (65 + Math.round(Math.random() * (90 - 65)));
			}
		}
		return new String(result);
	}

	public static int getPIN(){
		return (int) (1000 + Math.round(Math.random() * (9999 - 1000)));
	}

	public static void setDbPath(String path){
		//todo : check if the path points to a readable file ...
		dbName = path;;
	}

	/**
	 + Uses the SqliteBridge declared above to execute
	 + a sql- statement and returns a DbData Object, 
	 + which holds the resulting attribut- and tuplelist
	 + Use the boolean flag "isDML" to show the method
	 + that the sql statement is for instance "create
	 + table bla (..., ....)" You should not use the flag
	 + "false", if you are using the DML subset of the SQL
	 + language. 
	 + @return <p> A DbData Object </p>
	 + @param <p> The SQL-statement and the string representation of the database file </p>
	 + @throws <p> An IOException will be thrown if there was an error while executing the
	 + sql-statement </p>
	*/
	public static synchronized DbData execSql(String sql, boolean isDML ) throws IOException{
		DbData data = new DbData();
		if( isDML ){
			bridge.execSqlDML(sql,dbName, data);
			if(! data.errors.equals("NONE") ) {
				throw new IOException();
			}
		} else {
			bridge.execSql(sql, dbName, data);
			if (! data.errors.equals("NONE") ){
				throw new IOException();
			}
		}
		return data;
	}

	/**
	 + Deletes the whole dataset
	 + @return true, if the process was successful, else false
	*/
	public static boolean deleteTables(){
		try {
			DbData a = execSql("drop table if exists Customer", true);
			DbData b = execSql("drop table if exists Cashpoint", true);
			DbData c = execSql("drop table if exists Account", true);
			return (a.isOkay() && b.isOkay() && c.isOkay());
		} catch (IOException e) {
			System.out.println("[deleteTables] Ein Datenbankfehler trat auf...");
			return false;
		} catch (Exception e){
			e.printStackTrace();
			return false;
		}
	}

	/**
	 + resets the db "dbName"
	*/
	public static boolean resetDB(){
		try {
			//create the tables ...
			DbData d = execSql("create table Customer (C_ID varchar(30) not null primary key, Name varchar(30) not null, LastName varchar(30) not null, Street varchar(30) not null, Street_Nr varchar(30) not null, Account_ID varchar(30) not null references Account(Account_ID), Gender varchar(30) not null)", true);
			DbData g = execSql("create table Cashpoint (CP_ID varchar(30) not null primary key, Location varchar(30) not null, Amount_Money varchar(30) not null)", true);
			DbData f = execSql("create table Account ( Account_ID varchar(30) not null primary key, Balance varchar(20) not null)", true);	
			
			return (d.isOkay() && g.isOkay() && f.isOkay());
		} catch (IOException e) {
			return false;
		} catch (Exception e){ 
			e.printStackTrace();
			return false;
		}
	}
}
